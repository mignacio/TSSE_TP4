/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_sapi.h"

static const char* CMockString_buffer = "buffer";
static const char* CMockString_bufferSize = "bufferSize";
static const char* CMockString_config = "config";
static const char* CMockString_gpioInit = "gpioInit";
static const char* CMockString_gpioRead = "gpioRead";
static const char* CMockString_gpioToggle = "gpioToggle";
static const char* CMockString_gpioWrite = "gpioWrite";
static const char* CMockString_pin = "pin";
static const char* CMockString_spi = "spi";
static const char* CMockString_spiInit = "spiInit";
static const char* CMockString_spiRead = "spiRead";
static const char* CMockString_spiWrite = "spiWrite";
static const char* CMockString_value = "value";

typedef struct _CMOCK_gpioInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool_t ReturnVal;
  int CallOrder;
  gpioMap_t Expected_pin;
  gpioInit_t Expected_config;

} CMOCK_gpioInit_CALL_INSTANCE;

typedef struct _CMOCK_gpioRead_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool_t ReturnVal;
  int CallOrder;
  gpioMap_t Expected_pin;

} CMOCK_gpioRead_CALL_INSTANCE;

typedef struct _CMOCK_gpioWrite_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool_t ReturnVal;
  int CallOrder;
  gpioMap_t Expected_pin;
  bool_t Expected_value;

} CMOCK_gpioWrite_CALL_INSTANCE;

typedef struct _CMOCK_gpioToggle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool_t ReturnVal;
  int CallOrder;
  gpioMap_t Expected_pin;

} CMOCK_gpioToggle_CALL_INSTANCE;

typedef struct _CMOCK_spiInit_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool_t ReturnVal;
  int CallOrder;
  spiMap_t Expected_spi;

} CMOCK_spiInit_CALL_INSTANCE;

typedef struct _CMOCK_spiRead_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool_t ReturnVal;
  int CallOrder;
  spiMap_t Expected_spi;
  uint8_t* Expected_buffer;
  uint32_t Expected_bufferSize;
  char ReturnThruPtr_buffer_Used;
  uint8_t* ReturnThruPtr_buffer_Val;
  size_t ReturnThruPtr_buffer_Size;

} CMOCK_spiRead_CALL_INSTANCE;

typedef struct _CMOCK_spiWrite_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  bool_t ReturnVal;
  int CallOrder;
  spiMap_t Expected_spi;
  uint8_t* Expected_buffer;
  uint32_t Expected_bufferSize;
  char ReturnThruPtr_buffer_Used;
  uint8_t* ReturnThruPtr_buffer_Val;
  size_t ReturnThruPtr_buffer_Size;

} CMOCK_spiWrite_CALL_INSTANCE;

static struct mock_sapiInstance
{
  char gpioInit_IgnoreBool;
  bool_t gpioInit_FinalReturn;
  char gpioInit_CallbackBool;
  CMOCK_gpioInit_CALLBACK gpioInit_CallbackFunctionPointer;
  int gpioInit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpioInit_CallInstance;
  char gpioRead_IgnoreBool;
  bool_t gpioRead_FinalReturn;
  char gpioRead_CallbackBool;
  CMOCK_gpioRead_CALLBACK gpioRead_CallbackFunctionPointer;
  int gpioRead_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpioRead_CallInstance;
  char gpioWrite_IgnoreBool;
  bool_t gpioWrite_FinalReturn;
  char gpioWrite_CallbackBool;
  CMOCK_gpioWrite_CALLBACK gpioWrite_CallbackFunctionPointer;
  int gpioWrite_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpioWrite_CallInstance;
  char gpioToggle_IgnoreBool;
  bool_t gpioToggle_FinalReturn;
  char gpioToggle_CallbackBool;
  CMOCK_gpioToggle_CALLBACK gpioToggle_CallbackFunctionPointer;
  int gpioToggle_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpioToggle_CallInstance;
  char spiInit_IgnoreBool;
  bool_t spiInit_FinalReturn;
  char spiInit_CallbackBool;
  CMOCK_spiInit_CALLBACK spiInit_CallbackFunctionPointer;
  int spiInit_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spiInit_CallInstance;
  char spiRead_IgnoreBool;
  bool_t spiRead_FinalReturn;
  char spiRead_CallbackBool;
  CMOCK_spiRead_CALLBACK spiRead_CallbackFunctionPointer;
  int spiRead_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spiRead_CallInstance;
  char spiWrite_IgnoreBool;
  bool_t spiWrite_FinalReturn;
  char spiWrite_CallbackBool;
  CMOCK_spiWrite_CALLBACK spiWrite_CallbackFunctionPointer;
  int spiWrite_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE spiWrite_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_sapi_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.gpioInit_CallInstance;
  if (Mock.gpioInit_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpioInit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpioInit_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpioRead_CallInstance;
  if (Mock.gpioRead_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpioRead);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpioRead_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpioWrite_CallInstance;
  if (Mock.gpioWrite_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpioWrite);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpioWrite_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpioToggle_CallInstance;
  if (Mock.gpioToggle_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpioToggle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpioToggle_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spiInit_CallInstance;
  if (Mock.spiInit_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spiInit);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spiInit_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spiRead_CallInstance;
  if (Mock.spiRead_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spiRead);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spiRead_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.spiWrite_CallInstance;
  if (Mock.spiWrite_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spiWrite);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.spiWrite_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_sapi_Init(void)
{
  mock_sapi_Destroy();
}

void mock_sapi_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

bool_t gpioInit(gpioMap_t pin, gpioInit_t config)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpioInit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpioInit);
  cmock_call_instance = (CMOCK_gpioInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpioInit_CallInstance);
  Mock.gpioInit_CallInstance = CMock_Guts_MemNext(Mock.gpioInit_CallInstance);
  if (Mock.gpioInit_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpioInit_FinalReturn;
    Mock.gpioInit_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpioInit_CallbackBool &&
      Mock.gpioInit_CallbackFunctionPointer != NULL)
  {
    bool_t cmock_cb_ret = Mock.gpioInit_CallbackFunctionPointer(pin, config, Mock.gpioInit_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_gpioInit,CMockString_pin);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pin), (void*)(&pin), sizeof(gpioMap_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_gpioInit,CMockString_config);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_config), (void*)(&config), sizeof(gpioInit_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpioInit_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpioInit_CallbackFunctionPointer(pin, config, Mock.gpioInit_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpioInit(CMOCK_gpioInit_CALL_INSTANCE* cmock_call_instance, gpioMap_t pin, gpioInit_t config);
void CMockExpectParameters_gpioInit(CMOCK_gpioInit_CALL_INSTANCE* cmock_call_instance, gpioMap_t pin, gpioInit_t config)
{
  memcpy((void*)(&cmock_call_instance->Expected_pin), (void*)(&pin),
         sizeof(gpioMap_t[sizeof(pin) == sizeof(gpioMap_t) ? 1 : -1])); /* add gpioMap_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_config), (void*)(&config),
         sizeof(gpioInit_t[sizeof(config) == sizeof(gpioInit_t) ? 1 : -1])); /* add gpioInit_t to :treat_as_array if this causes an error */
}

void gpioInit_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpioInit_CALL_INSTANCE));
  CMOCK_gpioInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpioInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpioInit_CallInstance = CMock_Guts_MemChain(Mock.gpioInit_CallInstance, cmock_guts_index);
  Mock.gpioInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpioInit_IgnoreBool = (char)1;
}

void gpioInit_CMockStopIgnore(void)
{
  if(Mock.gpioInit_IgnoreBool)
    Mock.gpioInit_CallInstance = CMock_Guts_MemNext(Mock.gpioInit_CallInstance);
  Mock.gpioInit_IgnoreBool = (char)0;
}

void gpioInit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpioMap_t pin, gpioInit_t config, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpioInit_CALL_INSTANCE));
  CMOCK_gpioInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpioInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpioInit_CallInstance = CMock_Guts_MemChain(Mock.gpioInit_CallInstance, cmock_guts_index);
  Mock.gpioInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpioInit(cmock_call_instance, pin, config);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gpioInit_AddCallback(CMOCK_gpioInit_CALLBACK Callback)
{
  Mock.gpioInit_IgnoreBool = (char)0;
  Mock.gpioInit_CallbackBool = (char)1;
  Mock.gpioInit_CallbackFunctionPointer = Callback;
}

void gpioInit_Stub(CMOCK_gpioInit_CALLBACK Callback)
{
  Mock.gpioInit_IgnoreBool = (char)0;
  Mock.gpioInit_CallbackBool = (char)0;
  Mock.gpioInit_CallbackFunctionPointer = Callback;
}

bool_t gpioRead(gpioMap_t pin)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpioRead_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpioRead);
  cmock_call_instance = (CMOCK_gpioRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpioRead_CallInstance);
  Mock.gpioRead_CallInstance = CMock_Guts_MemNext(Mock.gpioRead_CallInstance);
  if (Mock.gpioRead_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpioRead_FinalReturn;
    Mock.gpioRead_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpioRead_CallbackBool &&
      Mock.gpioRead_CallbackFunctionPointer != NULL)
  {
    bool_t cmock_cb_ret = Mock.gpioRead_CallbackFunctionPointer(pin, Mock.gpioRead_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_gpioRead,CMockString_pin);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pin), (void*)(&pin), sizeof(gpioMap_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpioRead_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpioRead_CallbackFunctionPointer(pin, Mock.gpioRead_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpioRead(CMOCK_gpioRead_CALL_INSTANCE* cmock_call_instance, gpioMap_t pin);
void CMockExpectParameters_gpioRead(CMOCK_gpioRead_CALL_INSTANCE* cmock_call_instance, gpioMap_t pin)
{
  memcpy((void*)(&cmock_call_instance->Expected_pin), (void*)(&pin),
         sizeof(gpioMap_t[sizeof(pin) == sizeof(gpioMap_t) ? 1 : -1])); /* add gpioMap_t to :treat_as_array if this causes an error */
}

void gpioRead_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpioRead_CALL_INSTANCE));
  CMOCK_gpioRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpioRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpioRead_CallInstance = CMock_Guts_MemChain(Mock.gpioRead_CallInstance, cmock_guts_index);
  Mock.gpioRead_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpioRead_IgnoreBool = (char)1;
}

void gpioRead_CMockStopIgnore(void)
{
  if(Mock.gpioRead_IgnoreBool)
    Mock.gpioRead_CallInstance = CMock_Guts_MemNext(Mock.gpioRead_CallInstance);
  Mock.gpioRead_IgnoreBool = (char)0;
}

void gpioRead_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpioMap_t pin, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpioRead_CALL_INSTANCE));
  CMOCK_gpioRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpioRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpioRead_CallInstance = CMock_Guts_MemChain(Mock.gpioRead_CallInstance, cmock_guts_index);
  Mock.gpioRead_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpioRead(cmock_call_instance, pin);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gpioRead_AddCallback(CMOCK_gpioRead_CALLBACK Callback)
{
  Mock.gpioRead_IgnoreBool = (char)0;
  Mock.gpioRead_CallbackBool = (char)1;
  Mock.gpioRead_CallbackFunctionPointer = Callback;
}

void gpioRead_Stub(CMOCK_gpioRead_CALLBACK Callback)
{
  Mock.gpioRead_IgnoreBool = (char)0;
  Mock.gpioRead_CallbackBool = (char)0;
  Mock.gpioRead_CallbackFunctionPointer = Callback;
}

bool_t gpioWrite(gpioMap_t pin, bool_t value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpioWrite_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpioWrite);
  cmock_call_instance = (CMOCK_gpioWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpioWrite_CallInstance);
  Mock.gpioWrite_CallInstance = CMock_Guts_MemNext(Mock.gpioWrite_CallInstance);
  if (Mock.gpioWrite_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpioWrite_FinalReturn;
    Mock.gpioWrite_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpioWrite_CallbackBool &&
      Mock.gpioWrite_CallbackFunctionPointer != NULL)
  {
    bool_t cmock_cb_ret = Mock.gpioWrite_CallbackFunctionPointer(pin, value, Mock.gpioWrite_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_gpioWrite,CMockString_pin);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pin), (void*)(&pin), sizeof(gpioMap_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_gpioWrite,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  if (Mock.gpioWrite_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpioWrite_CallbackFunctionPointer(pin, value, Mock.gpioWrite_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpioWrite(CMOCK_gpioWrite_CALL_INSTANCE* cmock_call_instance, gpioMap_t pin, bool_t value);
void CMockExpectParameters_gpioWrite(CMOCK_gpioWrite_CALL_INSTANCE* cmock_call_instance, gpioMap_t pin, bool_t value)
{
  memcpy((void*)(&cmock_call_instance->Expected_pin), (void*)(&pin),
         sizeof(gpioMap_t[sizeof(pin) == sizeof(gpioMap_t) ? 1 : -1])); /* add gpioMap_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_value = value;
}

void gpioWrite_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpioWrite_CALL_INSTANCE));
  CMOCK_gpioWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpioWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpioWrite_CallInstance = CMock_Guts_MemChain(Mock.gpioWrite_CallInstance, cmock_guts_index);
  Mock.gpioWrite_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpioWrite_IgnoreBool = (char)1;
}

void gpioWrite_CMockStopIgnore(void)
{
  if(Mock.gpioWrite_IgnoreBool)
    Mock.gpioWrite_CallInstance = CMock_Guts_MemNext(Mock.gpioWrite_CallInstance);
  Mock.gpioWrite_IgnoreBool = (char)0;
}

void gpioWrite_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpioMap_t pin, bool_t value, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpioWrite_CALL_INSTANCE));
  CMOCK_gpioWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpioWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpioWrite_CallInstance = CMock_Guts_MemChain(Mock.gpioWrite_CallInstance, cmock_guts_index);
  Mock.gpioWrite_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpioWrite(cmock_call_instance, pin, value);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gpioWrite_AddCallback(CMOCK_gpioWrite_CALLBACK Callback)
{
  Mock.gpioWrite_IgnoreBool = (char)0;
  Mock.gpioWrite_CallbackBool = (char)1;
  Mock.gpioWrite_CallbackFunctionPointer = Callback;
}

void gpioWrite_Stub(CMOCK_gpioWrite_CALLBACK Callback)
{
  Mock.gpioWrite_IgnoreBool = (char)0;
  Mock.gpioWrite_CallbackBool = (char)0;
  Mock.gpioWrite_CallbackFunctionPointer = Callback;
}

bool_t gpioToggle(gpioMap_t pin)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpioToggle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpioToggle);
  cmock_call_instance = (CMOCK_gpioToggle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpioToggle_CallInstance);
  Mock.gpioToggle_CallInstance = CMock_Guts_MemNext(Mock.gpioToggle_CallInstance);
  if (Mock.gpioToggle_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpioToggle_FinalReturn;
    Mock.gpioToggle_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpioToggle_CallbackBool &&
      Mock.gpioToggle_CallbackFunctionPointer != NULL)
  {
    bool_t cmock_cb_ret = Mock.gpioToggle_CallbackFunctionPointer(pin, Mock.gpioToggle_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_gpioToggle,CMockString_pin);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pin), (void*)(&pin), sizeof(gpioMap_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpioToggle_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpioToggle_CallbackFunctionPointer(pin, Mock.gpioToggle_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpioToggle(CMOCK_gpioToggle_CALL_INSTANCE* cmock_call_instance, gpioMap_t pin);
void CMockExpectParameters_gpioToggle(CMOCK_gpioToggle_CALL_INSTANCE* cmock_call_instance, gpioMap_t pin)
{
  memcpy((void*)(&cmock_call_instance->Expected_pin), (void*)(&pin),
         sizeof(gpioMap_t[sizeof(pin) == sizeof(gpioMap_t) ? 1 : -1])); /* add gpioMap_t to :treat_as_array if this causes an error */
}

void gpioToggle_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpioToggle_CALL_INSTANCE));
  CMOCK_gpioToggle_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpioToggle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpioToggle_CallInstance = CMock_Guts_MemChain(Mock.gpioToggle_CallInstance, cmock_guts_index);
  Mock.gpioToggle_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpioToggle_IgnoreBool = (char)1;
}

void gpioToggle_CMockStopIgnore(void)
{
  if(Mock.gpioToggle_IgnoreBool)
    Mock.gpioToggle_CallInstance = CMock_Guts_MemNext(Mock.gpioToggle_CallInstance);
  Mock.gpioToggle_IgnoreBool = (char)0;
}

void gpioToggle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpioMap_t pin, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpioToggle_CALL_INSTANCE));
  CMOCK_gpioToggle_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpioToggle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpioToggle_CallInstance = CMock_Guts_MemChain(Mock.gpioToggle_CallInstance, cmock_guts_index);
  Mock.gpioToggle_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpioToggle(cmock_call_instance, pin);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gpioToggle_AddCallback(CMOCK_gpioToggle_CALLBACK Callback)
{
  Mock.gpioToggle_IgnoreBool = (char)0;
  Mock.gpioToggle_CallbackBool = (char)1;
  Mock.gpioToggle_CallbackFunctionPointer = Callback;
}

void gpioToggle_Stub(CMOCK_gpioToggle_CALLBACK Callback)
{
  Mock.gpioToggle_IgnoreBool = (char)0;
  Mock.gpioToggle_CallbackBool = (char)0;
  Mock.gpioToggle_CallbackFunctionPointer = Callback;
}

bool_t spiInit(spiMap_t spi)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spiInit_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spiInit);
  cmock_call_instance = (CMOCK_spiInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spiInit_CallInstance);
  Mock.spiInit_CallInstance = CMock_Guts_MemNext(Mock.spiInit_CallInstance);
  if (Mock.spiInit_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spiInit_FinalReturn;
    Mock.spiInit_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spiInit_CallbackBool &&
      Mock.spiInit_CallbackFunctionPointer != NULL)
  {
    bool_t cmock_cb_ret = Mock.spiInit_CallbackFunctionPointer(spi, Mock.spiInit_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_spiInit,CMockString_spi);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi), sizeof(spiMap_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.spiInit_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spiInit_CallbackFunctionPointer(spi, Mock.spiInit_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spiInit(CMOCK_spiInit_CALL_INSTANCE* cmock_call_instance, spiMap_t spi);
void CMockExpectParameters_spiInit(CMOCK_spiInit_CALL_INSTANCE* cmock_call_instance, spiMap_t spi)
{
  memcpy((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi),
         sizeof(spiMap_t[sizeof(spi) == sizeof(spiMap_t) ? 1 : -1])); /* add spiMap_t to :treat_as_array if this causes an error */
}

void spiInit_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spiInit_CALL_INSTANCE));
  CMOCK_spiInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spiInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spiInit_CallInstance = CMock_Guts_MemChain(Mock.spiInit_CallInstance, cmock_guts_index);
  Mock.spiInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spiInit_IgnoreBool = (char)1;
}

void spiInit_CMockStopIgnore(void)
{
  if(Mock.spiInit_IgnoreBool)
    Mock.spiInit_CallInstance = CMock_Guts_MemNext(Mock.spiInit_CallInstance);
  Mock.spiInit_IgnoreBool = (char)0;
}

void spiInit_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spiMap_t spi, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spiInit_CALL_INSTANCE));
  CMOCK_spiInit_CALL_INSTANCE* cmock_call_instance = (CMOCK_spiInit_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spiInit_CallInstance = CMock_Guts_MemChain(Mock.spiInit_CallInstance, cmock_guts_index);
  Mock.spiInit_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_spiInit(cmock_call_instance, spi);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void spiInit_AddCallback(CMOCK_spiInit_CALLBACK Callback)
{
  Mock.spiInit_IgnoreBool = (char)0;
  Mock.spiInit_CallbackBool = (char)1;
  Mock.spiInit_CallbackFunctionPointer = Callback;
}

void spiInit_Stub(CMOCK_spiInit_CALLBACK Callback)
{
  Mock.spiInit_IgnoreBool = (char)0;
  Mock.spiInit_CallbackBool = (char)0;
  Mock.spiInit_CallbackFunctionPointer = Callback;
}

bool_t spiRead(spiMap_t spi, uint8_t* buffer, uint32_t bufferSize)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spiRead_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spiRead);
  cmock_call_instance = (CMOCK_spiRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spiRead_CallInstance);
  Mock.spiRead_CallInstance = CMock_Guts_MemNext(Mock.spiRead_CallInstance);
  if (Mock.spiRead_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spiRead_FinalReturn;
    Mock.spiRead_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spiRead_CallbackBool &&
      Mock.spiRead_CallbackFunctionPointer != NULL)
  {
    bool_t cmock_cb_ret = Mock.spiRead_CallbackFunctionPointer(spi, buffer, bufferSize, Mock.spiRead_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_spiRead,CMockString_spi);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi), sizeof(spiMap_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spiRead,CMockString_buffer);
    if (cmock_call_instance->Expected_buffer == NULL)
      { UNITY_TEST_ASSERT_NULL(buffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buffer, buffer, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_spiRead,CMockString_bufferSize);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_bufferSize, bufferSize, cmock_line, CMockStringMismatch);
  }
  if (Mock.spiRead_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spiRead_CallbackFunctionPointer(spi, buffer, bufferSize, Mock.spiRead_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_buffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(buffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)buffer, (void*)cmock_call_instance->ReturnThruPtr_buffer_Val,
      cmock_call_instance->ReturnThruPtr_buffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spiRead(CMOCK_spiRead_CALL_INSTANCE* cmock_call_instance, spiMap_t spi, uint8_t* buffer, uint32_t bufferSize);
void CMockExpectParameters_spiRead(CMOCK_spiRead_CALL_INSTANCE* cmock_call_instance, spiMap_t spi, uint8_t* buffer, uint32_t bufferSize)
{
  memcpy((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi),
         sizeof(spiMap_t[sizeof(spi) == sizeof(spiMap_t) ? 1 : -1])); /* add spiMap_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_buffer = buffer;
  cmock_call_instance->ReturnThruPtr_buffer_Used = 0;
  cmock_call_instance->Expected_bufferSize = bufferSize;
}

void spiRead_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spiRead_CALL_INSTANCE));
  CMOCK_spiRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_spiRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spiRead_CallInstance = CMock_Guts_MemChain(Mock.spiRead_CallInstance, cmock_guts_index);
  Mock.spiRead_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spiRead_IgnoreBool = (char)1;
}

void spiRead_CMockStopIgnore(void)
{
  if(Mock.spiRead_IgnoreBool)
    Mock.spiRead_CallInstance = CMock_Guts_MemNext(Mock.spiRead_CallInstance);
  Mock.spiRead_IgnoreBool = (char)0;
}

void spiRead_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spiMap_t spi, uint8_t* buffer, uint32_t bufferSize, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spiRead_CALL_INSTANCE));
  CMOCK_spiRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_spiRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spiRead_CallInstance = CMock_Guts_MemChain(Mock.spiRead_CallInstance, cmock_guts_index);
  Mock.spiRead_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_spiRead(cmock_call_instance, spi, buffer, bufferSize);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void spiRead_AddCallback(CMOCK_spiRead_CALLBACK Callback)
{
  Mock.spiRead_IgnoreBool = (char)0;
  Mock.spiRead_CallbackBool = (char)1;
  Mock.spiRead_CallbackFunctionPointer = Callback;
}

void spiRead_Stub(CMOCK_spiRead_CALLBACK Callback)
{
  Mock.spiRead_IgnoreBool = (char)0;
  Mock.spiRead_CallbackBool = (char)0;
  Mock.spiRead_CallbackFunctionPointer = Callback;
}

void spiRead_CMockReturnMemThruPtr_buffer(UNITY_LINE_TYPE cmock_line, uint8_t* buffer, size_t cmock_size)
{
  CMOCK_spiRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_spiRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spiRead_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_buffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_buffer_Val = buffer;
  cmock_call_instance->ReturnThruPtr_buffer_Size = cmock_size;
}

bool_t spiWrite(spiMap_t spi, uint8_t* buffer, uint32_t bufferSize)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spiWrite_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spiWrite);
  cmock_call_instance = (CMOCK_spiWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spiWrite_CallInstance);
  Mock.spiWrite_CallInstance = CMock_Guts_MemNext(Mock.spiWrite_CallInstance);
  if (Mock.spiWrite_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.spiWrite_FinalReturn;
    Mock.spiWrite_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.spiWrite_CallbackBool &&
      Mock.spiWrite_CallbackFunctionPointer != NULL)
  {
    bool_t cmock_cb_ret = Mock.spiWrite_CallbackFunctionPointer(spi, buffer, bufferSize, Mock.spiWrite_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_spiWrite,CMockString_spi);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi), sizeof(spiMap_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_spiWrite,CMockString_buffer);
    if (cmock_call_instance->Expected_buffer == NULL)
      { UNITY_TEST_ASSERT_NULL(buffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buffer, buffer, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_spiWrite,CMockString_bufferSize);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_bufferSize, bufferSize, cmock_line, CMockStringMismatch);
  }
  if (Mock.spiWrite_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.spiWrite_CallbackFunctionPointer(spi, buffer, bufferSize, Mock.spiWrite_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_buffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(buffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)buffer, (void*)cmock_call_instance->ReturnThruPtr_buffer_Val,
      cmock_call_instance->ReturnThruPtr_buffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spiWrite(CMOCK_spiWrite_CALL_INSTANCE* cmock_call_instance, spiMap_t spi, uint8_t* buffer, uint32_t bufferSize);
void CMockExpectParameters_spiWrite(CMOCK_spiWrite_CALL_INSTANCE* cmock_call_instance, spiMap_t spi, uint8_t* buffer, uint32_t bufferSize)
{
  memcpy((void*)(&cmock_call_instance->Expected_spi), (void*)(&spi),
         sizeof(spiMap_t[sizeof(spi) == sizeof(spiMap_t) ? 1 : -1])); /* add spiMap_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_buffer = buffer;
  cmock_call_instance->ReturnThruPtr_buffer_Used = 0;
  cmock_call_instance->Expected_bufferSize = bufferSize;
}

void spiWrite_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spiWrite_CALL_INSTANCE));
  CMOCK_spiWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_spiWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spiWrite_CallInstance = CMock_Guts_MemChain(Mock.spiWrite_CallInstance, cmock_guts_index);
  Mock.spiWrite_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.spiWrite_IgnoreBool = (char)1;
}

void spiWrite_CMockStopIgnore(void)
{
  if(Mock.spiWrite_IgnoreBool)
    Mock.spiWrite_CallInstance = CMock_Guts_MemNext(Mock.spiWrite_CallInstance);
  Mock.spiWrite_IgnoreBool = (char)0;
}

void spiWrite_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, spiMap_t spi, uint8_t* buffer, uint32_t bufferSize, bool_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spiWrite_CALL_INSTANCE));
  CMOCK_spiWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_spiWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spiWrite_CallInstance = CMock_Guts_MemChain(Mock.spiWrite_CallInstance, cmock_guts_index);
  Mock.spiWrite_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_spiWrite(cmock_call_instance, spi, buffer, bufferSize);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void spiWrite_AddCallback(CMOCK_spiWrite_CALLBACK Callback)
{
  Mock.spiWrite_IgnoreBool = (char)0;
  Mock.spiWrite_CallbackBool = (char)1;
  Mock.spiWrite_CallbackFunctionPointer = Callback;
}

void spiWrite_Stub(CMOCK_spiWrite_CALLBACK Callback)
{
  Mock.spiWrite_IgnoreBool = (char)0;
  Mock.spiWrite_CallbackBool = (char)0;
  Mock.spiWrite_CallbackFunctionPointer = Callback;
}

void spiWrite_CMockReturnMemThruPtr_buffer(UNITY_LINE_TYPE cmock_line, uint8_t* buffer, size_t cmock_size)
{
  CMOCK_spiWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_spiWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.spiWrite_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_buffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_buffer_Val = buffer;
  cmock_call_instance->ReturnThruPtr_buffer_Size = cmock_size;
}

